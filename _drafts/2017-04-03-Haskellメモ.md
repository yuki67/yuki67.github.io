# Haskellメモ

[こないだ](https://yuki67.github.io/2017/03/14/python%E3%81%A7%E7%84%A1%E9%99%90%E3%83%AA%E3%82%B9%E3%83%88.html)やったことを遅延評価が標準のHaskellでやりました。ソースコードは[ここ](https://github.com/yuki67/yuki67.github.io/blob/master/non-markdowns/InfiniteList.hs)に。

内容としては前回の記事と同じなので、Haskellで書くにあたってつまづいた部分を書いておきます。

- ghciで宣言した変数/関数の型は確定しない。一方ソースコードにトップレベルで宣言した変数/関数は型が決定する。

  つまり

  ```haskell
  -- ghci
  Prelude> a = 1
  Prelude> :t a
  a :: Num t => t -- 型が確定してない
  ```

  となるのに対して、

  ```Haskell
  module Test where
  a = 1
  ```

  とだけ書いたTest.hsをghciで読み込むと

  ```haskell
  Prelude> :l "Test.hs"
  [1 of 1] Compiling Test             ( Test.hs, interpreted )
  Ok, modules loaded: Test.
  *Test> a
  1
  *Test> :t a
  a :: Integer -- 型が確定している
  ```

  となって型が確定します。

  しかしソースコードから読み込まれる変数/関数の型を曖昧にできないというわけではありません。

  Test.hsで

  ```haskell
  module Test where
  a :: Num a => a -- 型を明示する
  a = 1
  ```

  とすれば、

  ```haskell
  *Test> :l "Test.hs"
  [1 of 1] Compiling Test             ( Test.hs, interpreted )
  Ok, modules loaded: Test.
  *Test> a
  1
  *Test> :t a
  a :: Num a => a -- 型は曖昧
  ```

  と型を曖昧なままにできます。

  基本的にソースコードのトップレベルに書かれる変数/関数には型を常に書くべきなようです。(書かないとghc-modが "Top-level binding with no type signature" と警告を出すので。)
